# ---------------------------------------------------------
# Counts --------------------------------------------------
# ---------------------------------------------------------

# thegraph doesn't support count operations, but we need them to paginate results
# This entity is a workaround to this issue, but it's still not enough, as we'd need counts for more complex queries
type Count @entity {
  id: ID!

  orderTotal: Int!
  
  orderLand: Int!
  orderBoardingpass: Int!
  orderBuilding:Int!
  orderTower:Int!
  orderTrap:Int!
  # orderChest:Int!
  # orderAsset:Int!

  landTotal: Int!
  boardingpassTotal:Int!
  buildingTotal:Int!
  towerTotal:Int!
  trapTotal:Int!
  # chestTotal:Int!
  # assetTotal:Int!



  started: Int!
}

# ---------------------------------------------------------
# Orders --------------------------------------------------
# ---------------------------------------------------------

# thegraph doesn't support nested property searches, so we're doing promoting properties
# we need from each NFT type to the Order, in order to search for them, prefixing them with search_[nft]_[prop]
type Order @entity {
  id: ID!
  category: Category!
  nft: NFT
  nftAddress: Bytes!
  txHash: Bytes!
  owner: Bytes!
  buyer: Bytes
  price: BigInt!
  status: OrderStatus!
  blockNumber: BigInt!
  expiresAt: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
}

# ---------------------------------------------------------
# Bids ----------------------------------------------------
# ---------------------------------------------------------

type Bid @entity {
  id: ID!
  category: Category!
  nft: NFT
  nftAddress: Bytes!
  bidder: Bytes
  seller: Bytes
  price: BigInt!
  fingerprint: Bytes
  status: OrderStatus!
  blockchainId: String!
  blockNumber: BigInt!
  expiresAt: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
}

# ---------------------------------------------------------
# NFTs ----------------------------------------------------
# ---------------------------------------------------------

# aka LAND
#type Parcel @entity {
#  id: ID!
#  tokenId: BigInt!
#  owner: Account!
#  x: BigInt!
#  y: BigInt!
#  estate: Estate
#  data: Data
#  rawData: String
#  nft: NFT @derivedFrom(field: "parcel")
#}

# type Estate @entity {
#   id: ID!
#   tokenId: BigInt!
#   owner: Account!
#   parcels: [Parcel!]
#   size: Int
#   data: Data
#   rawData: String
#   nft: NFT @derivedFrom(field: "estate")
# }

type Land @entity {
  id: ID!
  tokenId: BigInt!
  owner: Account!
  data: Data
  rawData: String
  nft: NFT @derivedFrom(field: "land")
  x:Int!
  y:Int!
  # name:String!
}



type Data @entity {
  id: ID!
  version: String!
  name: String
  description: String
  ipns: String
}
# Chest is not real NFT
type Chest @entity{
  id: ID!
  owner: Account!
  nft: NFT @derivedFrom(field: "chest")
  tokenId: BigInt!
  name: String!

}
type Boardingpass @entity{
  id: ID!
  owner: Account!
  nft: NFT @derivedFrom(field: "boardingpass")
  tokenId: BigInt!
  # name: String!

}
type Building @entity{
  id: ID!
  owner: Account!
  nft: NFT @derivedFrom(field: "building")
  tokenId: BigInt!
  subCategory: String!
}
type Tower @entity{
  id: ID!
  owner: Account!
  nft: NFT @derivedFrom(field: "tower")
  tokenId: BigInt!
  subCategory: String!
}

type Trap @entity{
  id: ID!
  owner: Account!
  nft: NFT @derivedFrom(field: "trap")
  tokenId: BigInt!
  subCategory: String!
}


# type Wearable @entity {
#   id: ID!
#   owner: Account!
#   representationId: String!
#   collection: String!
#   name: String!
#   description: String!
#   category: WearableCategory!
#   rarity: WearableRarity!
#   bodyShapes: [WearableBodyShape!]
#   nft: NFT @derivedFrom(field: "wearable")
# }

# type ENS @entity {
#   id: ID!
#   tokenId: BigInt!
#   owner: Account!
#   caller: Bytes
#   beneficiary: Bytes
#   labelHash: Bytes
#   subdomain: String
#   createdAt: BigInt
#   nft: NFT @derivedFrom(field: "ens")
# }

type NFT @entity {
  id: ID!
  tokenId: BigInt!
  contractAddress: Bytes!
  category: Category!
  subcategory:String
  owner: Account!
  tokenURI: String

  orders: [Order!] @derivedFrom(field: "nft") # History of all orders. Should only ever be ONE open order. all others must be cancelled or sold
  bids: [Bid!] @derivedFrom(field: "nft") # History of all bids.
  activeOrder: Order

  name: String
  image: String

  # parcel: Parcel
  # estate: Estate
  # wearable: Wearable
  # ens: ENS
  # asset:Asset
  boardingpass:Boardingpass
  land:Land
  building:Building
  tower:Tower
  trap:Trap
  chest:Chest



  createdAt: BigInt!
  updatedAt: BigInt!

  # search indexes
  searchOrderStatus: OrderStatus
  searchOrderPrice: BigInt
  searchOrderExpiresAt: BigInt
  searchOrderCreatedAt: BigInt

  searchIsLand: Boolean

  searchText: String

  # searchParcelIsInBounds: Boolean
  # searchParcelX: BigInt
  # searchParcelY: BigInt
  # searchParcelEstateId: String

  searchEstateSize: Int

  # searchIsWearableHead: Boolean
  # searchIsWearableAccessory: Boolean
  # searchWearableRarity: String # We're using String instead of WearableRarity here so we can later query this field via ()_in
  # searchWearableCategory: WearableCategory
  # searchWearableBodyShapes: [WearableBodyShape!]
}

# ---------------------------------------------------------
# Account (user) -------------------------------------------
# ---------------------------------------------------------

# type Asset @entity {
#   id: ID!
#   owner: Account!
#   nft: NFT @derivedFrom(field: "asset")
#   tokenId: BigInt!
# }


type Account @entity {
  id: ID! # ETH addr
  address: Bytes!
  nfts: [NFT!] @derivedFrom(field: "owner")
  spay: BigInt # Amount of spay owned
}






# ---------------------------------------------------------
# Enums ---------------------------------------------------
# ---------------------------------------------------------

enum Category @entity {
  asset
  land
  boardingpass
  building
  tower
  trap
}

enum OrderStatus @entity {
  open
  sold
  cancelled
}



enum Rarity @entity {
  rare
  epic
  legendary
  mythic
  unique
}


